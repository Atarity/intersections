#!/bin/sh -e

# Intersections - A simple bash-based static site generator for links
# Usage: ./intersections "url" "comment"

domain="https://snnkv.com/"
ts=$(date '+%Y-%m-%d')
rssdate=$(date -R)
# Argument parsing
skip_confirm=0
if [ "$1" = "-y" ]; then
    skip_confirm=1
    shift
fi

url_original=$1
comment=$2

if [ -z "$url_original" ]; then
    echo "Usage: ./intersections [-y] <url> [comment]"
    exit 1
fi

# Normalize URL for display (strip protocols and www)
url_display=$(echo "$url_original" | sed -E 's|^https?://||; s|^www\.||; s|/$||')

# Fetch title from target page (limited to 5 seconds, follow redirects)
fetch_title() {
    # Use python3 to extract title and unescape entities robustly (handles UTF-8)
    title=$(curl -sL --max-time 5 "$1" | python3 -c 'import sys, re, html; m = re.search(r"(?i)<title[^>]*>(.*?)</title>", sys.stdin.read(), re.S); print(html.unescape(m.group(1).strip()) if m else "")' 2>/dev/null | tr -d '\r\n')
    printf '%s\n' "$title" | cut -c 1-200
}

echo "Fetching title for $url_original..."
page_title=$(fetch_title "$url_original")

# Fallback if title is empty
if [ -z "$page_title" ]; then
    page_title="$url_display"
fi

# Interactive edit (heavily zsh, macos -dependent)
if [ "$skip_confirm" -eq 0 ]; then
    tmp_title=$(mktemp)
    zsh -c 'title=$1; vared -p "Edit title: " title; echo "$title"' -- "$page_title" > "$tmp_title" < /dev/tty
    page_title=$(cat "$tmp_title")
    rm "$tmp_title"
fi

# Prepare HTML entry for timeline.htm
comment_html=""
if [ -n "$comment" ]; then
    comment_html="<div class='comment-wrapper'>
    <div class='avatar'><img src='meta/avatar-bl.svg' alt=''></div>
    <p class='comment'>$comment</p>
  </div>"
fi

printf "<article id='%s'>
  <div class='entry-header'>
    <span class='ts'>%s</span>
    <h2 class='entry-title'><a href='%s' target='_blank'>%s</a></h2>
    <a href='%s' class='url' target='_blank'>%s</a>
  </div>
  %s
</article>\n" "$url_display" "$ts" "$url_original" "$page_title" "$url_original" "$url_display" "$comment_html" > meta/last.htm

# Prepend last entry to timeline.htm
touch meta/timeline.htm
cat meta/last.htm meta/timeline.htm > meta/_timeline.htm
mv meta/_timeline.htm meta/timeline.htm

# Assemble index.html
rm -f index.html
cat meta/header.htm meta/timeline.htm meta/footer.htm > index.html

# Helper to escape XML special characters
xml_escape() {
    printf '%s\n' "$1" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'"'"'/\&apos;/g'
}

# Prepare RSS item (inlined echo with XML escaping)
rss_page_title=$(xml_escape "$page_title")
rss_url_original=$(xml_escape "$url_original")
rss_comment=$(xml_escape "$comment")

cat <<EOF > meta/rss_last.tmpl
<item>
  <title>$rss_page_title</title>
  <link>$rss_url_original</link>
  <description>$rss_comment</description>
  <pubDate>$rssdate</pubDate>
  <guid>$rss_url_original</guid>
</item>
EOF

# Prepend last RSS item to rss_timeline.tmpl
touch meta/rss_timeline.tmpl
cat meta/rss_last.tmpl meta/rss_timeline.tmpl > meta/_rss_timeline.tmpl
mv meta/_rss_timeline.tmpl meta/rss_timeline.tmpl

# Assemble feed.xml (Top 20 items)
rm -f feed.xml
cat meta/rss_header.tmpl > feed.xml
printf "  <lastBuildDate>%s</lastBuildDate>\n" "$rssdate" >> feed.xml

# Take top 20 items (roughly 7 lines per item)
awk '/<item>/ { c++ } c <= 20' meta/rss_timeline.tmpl >> feed.xml

printf "</channel>\n</rss>\n" >> feed.xml

echo "-------"
echo "Title: $page_title"
echo "Link added: $url_display"
echo "Comment: $comment"
echo "index.html and feed.xml updated."

# Auto-commit and push
if [ -d .git ]; then
    git status --short && git add -A && git commit -m "Add link: $url_display"
    git push
fi
